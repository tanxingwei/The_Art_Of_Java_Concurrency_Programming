### Java 内存模型基础

## 1. 概述

JAVA内存模型包括的内容

1. 顺序一致性(重排序与顺序一致性内存模型)
2. 同步原语(synchronized, volatile, finnal)的内存语义
3. JMM的<font color=red>**可见性保证**</font>(Happens-Before, as-if-serial) 

## 2. JMM概述

在聊JMM之前需要知道并发编程中的两个关键的问题: **线程之间如何通信以及线程之间如何进行同步**

**通信**: 线程之间以何种机制交换信息, 主要有共享内存和消息传递两种方式

​		共享内存通信机制: *线程共享进程中被分配的内存*, 也就是有一个公共状态, 通过读写内存中的公共状态进行**隐式通信**

​		消息传递:	线程之间没有公共状态, 需要**显式**发消息给其他线程进行通信

**同步**: 程序控制不同线程操作发生相对顺序

​		共享内存并发模型: 需要编写代码进行互斥操作, 是显式同步

​		消息传递并发模型: 由于发送消息必须在接受消息之前,因此是隐式的

### JAVA内存模型

JAVA内存模型, 从抽象的角度来说的话, 是定义了线程与主内存之间的抽象关系: 线程之间的共享变量存储在主内存之中, 而每个线程中有一个本地内存(概念上的, 实际上并不存在)用于存放该线程用到的共享变量的副本.

结合JVM来看的话, 可以把主内存理解成一个JVM堆内存的子集.只存放线程之间的共享变量对象实例. 而本地内存相对而言可以理解成每个线程都持有的一个虚拟机栈的部分数据.

![img](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/07/20240107-161109.png)

// todo 可以插入MESI缓存一致性协议

## 3. 指令重排序

为了提高性能, 编译器和处理器尝尝会对指令做重排序. 重排序分为以下三种

1. 编译器优化重排序（Compiler Reordering）：编译器在保持程序语义不变的前提下，通过重新安排指令的执行顺序来提高性能。编译器重排序可以包括指令的重排、循环展开、代码内联等。

2. 指令级并行重排序（Processor Reordering）：指使用指令级并行技术来将多条指令重叠执行,如果没有数据依赖性, 处理器可以改变语句对应机器指令的执行顺序。

   ```
   数据依赖性: 如果两个操作访问同一个变量, 且其中一个操作为写操作, 则这两个操作有数据依赖性. 主要有写后读, 读后写, 写后写.
   ```

3. 内存重排序（Memory Reordering）：由于处理器使用缓存和读写缓冲区, 这使得加载和存储操作看起来像是在乱序执行. 内存重排序可能导致不同处理器或多线程之间对共享数据的访问顺序产生不一致，从而引发内存一致性问题.

![在这里插入图片描述](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/07/20240107-170812.png)

在**编译器的重排序**上,JMM编译器重排序规则会禁止特定类型的编译器重排序

例如: 

1. 在单个线程内，禁止将一个操作的执行顺序重排序到该操作的前面，也禁止将一个非 volatile 操作的执行顺序重排序到该操作的后面。这条规则确保了在单个线程内，操作的执行顺序与程序代码的顺序一致，避免了指令的乱序执行。
2. 在单个线程内，禁止将一个对象的构造函数中的操作顺序重排序到构造函数之外。这条规则保证了在构造函数中的操作按照程序代码的顺序进行执行，避免了构造函数中的指令重排序可能带来的问题。
3. 在单个线程内，禁止将一个对象的 final 字段的写操作重排序到构造函数之外。这条规则保证了对 final 字段的写操作在构造函数完成之前完成，避免了 final 字段在对象构造过程中的不一致性。

在**处理器重排序**上, 则是通过插入内存屏障来实现禁止特定的处理器重排序.

**内存屏障则解决了硬件层面的可见性与重排序问题**。

| 屏障类型            | 指令示例                 | 说明                                                         |
| :------------------ | :----------------------- | :----------------------------------------------------------- |
| LoadLoad Barriers   | Load1;LoadLoad;Load2     | 该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作 |
| StoreStore Barriers | Store1;StoreStore;Store2 | 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 |
| LoadStore Barriers  | Load1;LoadStore;Store2   | 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 |
| StoreLoad Barriers  | Store1;StoreLoad;Load2   | 该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 |

## 4. 顺序一致性

## 5. happens-before 与 as-if-serial

## 6. 同步原语的内存语义

### volatile 

### synchronized

### finnal

## 总结

