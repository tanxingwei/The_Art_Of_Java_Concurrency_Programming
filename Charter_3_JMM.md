### Java 内存模型基础

## 1. 概述

### <font color=red>什么是内存模型</font>

​	内存模型是计算机系统中用于<font color=red>描述多线程或多进程并发执行时，共享内存的访问规则和顺序的抽象模型。它定义了线程或进程之间如何进行内存访问、读取和写入共享数据的顺序，并确保这些访问的正确性和一致性</font>。
​	在并发编程中，多个线程或进程可以同时访问和修改共享内存中的数据。内存模型定义了这些操作的可见性和排序规则，以确保程序的执行结果是可预期和一致的。
​	内存模型的主要目标是解决由于并发访问共享数据可能引发的一些问题，例如竞态条件（race conditions）、原子性问题（atomicity violations）和可见性问题（visibility problems）。它通过规定一些规则和约束来确保对共享数据的访问和修改满足一定的顺序和条件，从而避免潜在的错误和不确定性

### JAVA内存模型包括的内容

1. 顺序一致性(重排序与顺序一致性内存模型)
2. 同步原语(synchronized, volatile, finnal)的内存语义
3. JMM的<font color=red>**可见性保证**</font>(Happens-Before, as-if-serial) 

内存模型应对的最大的问题就是重排序和访问顺序, 目的则是为了保证程序之间的可见性.

## 2. JMM概述

在聊JMM之前需要知道并发编程中的两个关键的问题: **线程之间如何通信以及线程之间如何进行同步**

**通信**: 线程之间以何种机制交换信息, 主要有共享内存和消息传递两种方式

​		共享内存通信机制: *线程共享进程中被分配的内存*, 也就是有一个公共状态, 通过读写内存中的公共状态进行**隐式通信**

​		消息传递:	线程之间没有公共状态, 需要**显式**发消息给其他线程进行通信

**同步**: 程序控制不同线程操作发生相对顺序

​		共享内存并发模型: 需要编写代码进行互斥操作, 是显式同步

​		消息传递并发模型: 由于发送消息必须在接受消息之前,因此是隐式的

### JAVA内存模型

JAVA内存模型, 从抽象的角度来说的话, 是定义了线程与主内存之间的抽象关系: 线程之间的共享变量存储在主内存之中, 而每个线程中有一个本地内存(概念上的, 实际上并不存在)用于存放该线程用到的共享变量的副本.

结合JVM来看的话, 可以把主内存理解成一个JVM堆内存的子集.只存放线程之间的共享变量对象实例. 而本地内存相对而言可以理解成每个线程都持有的一个虚拟机栈的部分数据.

![img](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/07/20240107-161109.png)

// todo 可以插入MESI缓存一致性协议

## 3. 指令重排序

为了提高性能, 编译器和处理器尝尝会对指令做重排序. 重排序分为以下三种

1. 编译器优化重排序（Compiler Reordering）：编译器在保持程序语义不变的前提下，通过重新安排指令的执行顺序来提高性能。编译器重排序可以包括指令的重排、循环展开、代码内联等。

2. 指令级并行重排序（Processor Reordering）：指使用指令级并行技术来将多条指令重叠执行,如果没有数据依赖性, 处理器可以改变语句对应机器指令的执行顺序。

   ```
   数据依赖性: 如果两个操作访问同一个变量, 且其中一个操作为写操作, 则这两个操作有数据依赖性. 主要有写后读, 读后写, 写后写.
   ```

3. 内存重排序（Memory Reordering）：由于处理器使用缓存和读写缓冲区, 这使得加载和存储操作看起来像是在乱序执行. 内存重排序可能导致不同处理器或多线程之间对共享数据的访问顺序产生不一致，从而引发内存一致性问题.

![在这里插入图片描述](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/07/20240107-170812.png)

在**编译器的重排序**上,JMM编译器重排序规则会禁止特定类型的编译器重排序

例如: 

1. 在单个线程内，禁止将一个操作的执行顺序重排序到该操作的前面，也禁止将一个非 volatile 操作的执行顺序重排序到该操作的后面。这条规则确保了在单个线程内，操作的执行顺序与程序代码的顺序一致，避免了指令的乱序执行。
2. 在单个线程内，禁止将一个对象的构造函数中的操作顺序重排序到构造函数之外。这条规则保证了在构造函数中的操作按照程序代码的顺序进行执行，避免了构造函数中的指令重排序可能带来的问题。
3. 在单个线程内，禁止将一个对象的 final 字段的写操作重排序到构造函数之外。这条规则保证了对 final 字段的写操作在构造函数完成之前完成，避免了 final 字段在对象构造过程中的不一致性。

在**处理器重排序**上, 则是通过插入内存屏障来实现禁止特定的处理器重排序.

**内存屏障则解决了硬件层面的可见性与重排序问题**。

| 屏障类型            | 指令示例                 | 说明                                                         |
| :------------------ | :----------------------- | :----------------------------------------------------------- |
| LoadLoad Barriers   | Load1;LoadLoad;Load2     | 该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作 |
| StoreStore Barriers | Store1;StoreStore;Store2 | 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 |
| LoadStore Barriers  | Load1;LoadStore;Store2   | 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 |
| StoreLoad Barriers  | Store1;StoreLoad;Load2   | 该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 |

StoreLoad屏障是一个全能型的屏障, 它同时具有其他三个屏障的效果.但是执行该屏障的开销很高.

## 4. 顺序一致性

在JAVA内存模型中, 数据竞争的定义是: 在一个线程中写一个变量, 在另一个线程中读同一个变量, 且读和写没有使用同步机制来排序.

如果程序同步正确, 程序的执行将具有顺序一致性, 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同.

### 顺序一致性内存模型

**特性:**

1. 一个线程中的所有操作必须按照程序的顺序来执行
2. (不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序.在顺序一致性内存模型中, 每个操作都必须原子执行且立刻对所有线程可见

![img](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/07/20240107-222705.png)

<center style="color:#C0C0C0;text-decoration:underline">顺序一致性内存模型抽象结构图</center>

在概念上, 顺序一致性内存模型有一个单一的全局内存, 这个内存通过一个左右摆动的开关可以连接到任意一个线程, 同时每一个线程必须按照程序的顺序来执行内存的读/写操作.实际上就是时间点只有一个线程连接全局内存,并且<font color=red>**串行化**</font>执行读写操作.

#### 同步程序与未同步程序的执行特性

**在同步程序中, JMM在临界区前后在不改变程序结构的情况下会进行指令重排.**而顺序一致性模型则必须按照程序的语句顺序进行执行.

在未同步的程序中, JMM只提供**最小安全性**, 即线程执行时读取到的值要么是之前某个线程写入的值, 要么是默认值.而不会是无中生有的. **但是不保证正确性**, 例如对象的初始化.

就结果而言, JMM程序执行的结果不保证与顺序一致性内存模型的结果相同,而未同步的程序在顺序一致性内存模型上的执行路径也是整体无序的(单个线程内有序), 其结果也是未知的.

#### JMM与顺序一致性内存模型的差异

1. 顺序一致性内存模型按程序顺序执行, 而JMM存在指令重排
2. 顺序一致性内存模型保证所有线程可以看见一致的执行顺序(操作变量直接刷到全局内存中, 并且所有线程可见), 而JMM不能保证(线程有自身的本地内存, 放有共享变量的副本)
3. JMM不能保证对读long, double类型的变量具有原子性(一些32位处理器, 可能会把对64位的long,double类型变量分解为两次32位的写操作进行).而顺序一致性内存模型可以保证所有对内存的读写操作都具有原子性

在同步的程序中, 顺序一致性内存模型相当于一板一眼的写出过程的参考答案,而JMM则是在正确答案的过程中省略合并了某些步骤. 



## 5. happens-before 与 as-if-serial

#### as-if-serial

as-if-serial语义:不管怎么重排序(编译器和处理器为了提高CPU的并行度),单线程程序的执行结果不能改变.



#### happens-before

**什么是happens-before**

happens-before的概念是用来**<font color=red>指定两个操作之间的顺序</font>**,两个操作可以在同一个线程内也可以在不同的线程.因此可以用于提供跨线程的内存可见性.

**happens-before关系**

**1. 如果一个操作happens-before于另一个操作, 那么第一个操作的执行结果将对第二个操作可见, 并且第一个操作的执行顺序排在第二个之前.**

这是对程序员的保证, 如果 A happens-before B, 那么A的操作结果将对B可见, 且A的执行顺序会在B之前.

**2. 如果两个操作存在happens-before关系, 但是并不意味着JAVA平台的具体实现必须按昭happens-before关系的指定顺序来.**

这个是**对编译器和处理器重排序的约束**, 如果不改变程序的运行结果, 编译器和处理器怎么优化都可以.

**happens-before与as-if-serial**

区别:

as-if-serial语义保证单线程内的程序的执行结果不被改变, happens-before则是保证**完全同步正确**的多线程程序的执行结果不被改变.
as-if-serial语义给编写单线程程序的程序员创建了一个幻觉: 单线程程序是按照程序的来执行的, as-if-serial使程序员不用担心重排序和内存可见性问题;而happens-before则是给编写完全正确同步的程序员创造了一个幻境: 完全正确同步的多线程程序是按照happens-before关系指定的顺序执行的.

共性:
都是为了在不改变程序运行结果的前提下,尽可能提高线程的并发度.

#### happens-before的规则

程序规则: 一个线程中的每个操作, happens-before与该线程中的任意后续操作

监视器锁规则: 对于一个锁的解锁, happens-before于随后对这个锁的加锁

volatile规则: 对于一个volatile写操作, happens-before与任意后续对该变量的读操作

传递性规则: 如果 A happens-before B, 且B happens-before C, 那么  A happens-before于C

start()规则: 如果在A执行B.start(), 那么A线程中的B.start() happens-before于任意B线程中的任意操作

join()规则: 



## 6. 同步原语的内存语义

### volatile 

#### volatile的特性

1. **可见性**

   对volatile变量的读操作, 总是能看到最后一次的写结果. 或者 每一次的写操作都对任意线程可见

2. **原子性**

   任意对单个的volatile变量的读写操作具有原子性.

初见懵逼预告: **<font color=red>volatile写和锁的释放有相同的内存语义,volatile读与锁的获取有相同的内存语义.</font>**

上面那句话其实是需要从内存可见性这个方面去分析.

volatile写和锁的释放有相同的内存语义: 
		在写一个volatile变量的时候, 会在写命令之后插入一个Store内存屏障, 防止指令重排.以确保在完成写操作后, 这个volatile变量对其他线程是可见的
		而在释放锁的时候,在临界区结束后, 释放锁这个操作也同样是需要对其他线程可见.并且根据happens-before规则, 一个锁的释放happens-before与一个锁的加锁.

volatile读与锁的获取有相同的内存语义.
		在读一个volatile变量的时候, 会插入一个Load类型的内存屏障, 保证这个读操作读到的是最新的写入结果
		类似的情况是锁的获取, 在获取一个锁之前, 在锁释放之前的所有操作对当前的加锁操作都是可见的.

#### volatile的读写内存语义

//  这里的具体底层实现参考MESI协议

当写一个volatile变量时, JMM会将该线程中的本地共享变量副本副本刷新到主内存中.

当读一个volatile变量时, JMM会将本地内存中的共享变量副本设为无效,再从主内存中读取.

#### 重排序规则

![重排序示意表](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/01/13/20240113-015634.png)

当第二个操作是volatile写时, 不管第一个操作是什么, 都不能重排序.
当第一个操作是volatile读时, 不管第二个操作是什么, 都不能重排序.

#### 内存屏障

在volatile写之前, 插入StoreStore屏障,  保证volatile写操作之前 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作

### synchronized



### finnal

这一块可以参考java并发编程实践中的对象的发布与共享一章

## 总结

参考文档: 

[Java内存访问重排序的研究](https://tech.meituan.com/2014/09/23/java-memory-reordering.html)

